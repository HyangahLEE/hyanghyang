package days10;

public class Ex09 {

	public static void main(String[] args) {
		/*
		
		[막대기 자르기]


				각각 0이상의 정수를 길이로 하는 N개의 막대기가 있다. 이 막대기들 중 가장 짧은 막대기의 길이로 모든 막대기를 자르는 것을 [cut operation]이라고 하자.

				예를 들어 6개의 막대기가 있고 그 길이가 다음과 같다면 

				5 4 4 2 2 8 

				이 경우 [Cut Operation]을 한번 수행하면 다음과 같다. 

				3 2 2 6

				(가장 짧은 길이인 2로 6개의 막대기를 잘라내고 길이가 0이 되버린 2개의 막대기는 버려진다.) 

				N개의 막대기와 그 각각의 길이가 주어졌을 때 [Cut Operation]을 모든 막대기가 버려질 때(길이가 0이 될때)까지 반복하고  수행 시 마다 남은 막대기의 수를 출력하는 프로그램을 작성하라. 

				입력 
				첫줄에 막대기의 수 N을, 다음 줄에 각각의 막대기의 길이를 공백으로 구분해서 입력한다.

				출력 
				매 줄마다 [Cut Operation]이 수행 되 때 마다 남은 막대기의 수를 출력 

				제한 
				1 <= N <= 1000
				1 <= 막대기의 길이 <= 1000

				입력 예제 #1
				6
				5 4 4 2 2 8

				출력 예제 #1
				6
				4
				2
				1

				입력 예제 #2
				8
				1 2 3 4 3 3 2 1

				출력 예제 #2
				8
				6
				4
				1 

				-----------------------------------------------------------------------------------

				정수쌍(Pairs)


				N개의 정수가 주어졌을 때 그 차가 K인 정수 쌍의 수를 구하시오 

				입력
				첫째 줄에 N, K를 입력받는다. (스페이스로 구분) 
				두번째 줄부터 N개의 정수를 입력받는다. 단, 모든 정수는 그 값이 서로 달라야 한다. (스페이스로 구분)

				출력 
				차가 K인 정수 쌍의 수를 출력한다. 

				제한 
				N <= 10^5
				0 < K < 10^9 
				각 정수는 0보다 크고 2^31 - 1 보다 작다. 

				예제 입력 #1
				5 2 
				1 5 3 4 2 

				예제 출력 #1
				3

				예제 입력 #2
				10 1 
				363374326 364147530 61825163 1073065718 1281246024 1399469912 428047635 491595254 879792181 1069262793 

				예제 출력 #2
				0

				가산점 

				N개의 정수를 입력받았을 때 각각의 차가 K인것을 체크하려면 N^2의 비교가 필요하고 N이 커질수록 처리속도가 급격히 증가하게 된다. 
				이를 해결하기 위해 Time Complecity가 O(N log N)이거나 이보다 효율적으로 구현하도록 구현 하면 가산점 추가됨. 


				-----------------------------------------------------------------------------------

				배열의 무게 중심


				[A1][A2]....[An]으로 이루어진 배열이 있다. 이 배열에서 다음의 조건을 만족하는 요소 Ai가 있는지 검사하는 프로그램을 작성하시오
				1. Ai의 왼쪽에 있는 요소들의 합과 오른쪽에 있는 요소들의 합이 동일하다. 
				2. 왼쪽이나 오른쪽에 요소가 없다면 (A1이거나 An이라면) 합은 0으로 간주한다. 

				즉 [A1] + [A2].... [Ai-1] = [Ai+1] + [Ai+2] + [An] 

				입력 
				첫 번째 줄에 테스트 케이스의 수를 입력한다. 
				각 테스트 케이스에서 첫번째 줄은 배열의 크기 N을 그 다음 줄은 스페이스로 구분한 배열의 요소들을 입력받는다. 

				출력 
				각각의 테스트 케이스에 대해서 Ai가 존재하면 YES를 그렇지 않으면 No를 출력한다. 

				입력 예제 #1 
				2
				3
				1 2 3
				4
				1 2 3 3

				출력 예제 #1
				NO
				YES

				예제 설명 #1 
				첫번째 케이스에서는 만족하는 것을 찾을 수 없다. 
				두번째 케이스에서는 A[1] + A[2] = A[4]이다.

				가산점 
				처리 속도를 향상시키면 가산점 

				-----------------------------------------------------------------------------------

				정수 트리플 (Triples)


				정수 배열 d가 있다. 
				다음을 만족하는 트리플의 수를 구하라 
				d[i] < d[j] < d[k], i < j < k 

				입력
				첫째 줄에 배열의 크기 N을 입력바는다. 
				두번째 줄에는 N개의 정수를 입력받는다. (스페이스로 구분) 

				출력 
				문제의 조건을 만족하는 트리플의 수를 출력한다. 

				제한 
				N <= 10^5
				배열에 속한 모든 정수값은 0보다 크고 2^16 - 1 보다 작다. 

				예제 입력 #1
				6 
				1 1 2 2 3 4

				예제 출력 #1
				4 

				예제 설명 #1 
				조건을 만족하는 트리플은 다음과 갔다. 
				(1,2,3) 
				(1,2,4) 
				(1,3,4) 
				(2,3,4) 

				-----------------------------------------------------------------------------------

				9와 0


				숫자 0과 9로만 이루어진 0 이상의 정수 X가 있다. (ex: 90, 9990, 9009009) 
				0이상의 정수 N이 주어졌을 때 X중 N의 배수이면서 가장 작은 수를 구하는 프로그램을 작성하시요. 

				입력 
				첫줄에 테스트 케이스 T를 입력 받는다. 다음 줄 부터 T줄만큼 N을 입력받는다. 

				출력 
				각각의 테스트 케이스에 대해서 조건 만족하는 수 X를 한줄에 하나씩 출력한다. 단 숫자 앞에 0이 와서는 안된다. 
				(ex: 00999 > 999로 출력할 것) 

				제한 
				1 <= T <= 104 
				1 <= N <= 500

				입력 예제 #1
				3
				5
				7
				1

				출력 예제 #1
				90
				9009
				9

				예제 설명 #1
				첫번째 테스트 케이스 : 5의 배수이면서 9와 0으로만 이루어진 가장 작은 수는 90이다. 


				-----------------------------------------------------------------------------------

				주식 투자


				당신은 오늘 부터 N일(DAY) 동안의 삼성전자 주가를 예측할 수있는 알고리즘을 개발했다(와우~!!!). 

				다만 현재 예산으로는 N일 동안 각각의 날에 다음의 액션중 하나만을 취할 수 있다. 

				1) 어떤 날은 삼성전자 주식 1주를 살 수 있다. 
				2) 어떤 날은 가지고 있는 주식 중 일부 혹은 전부를 팔 수 있다
				3) 어떤 날은 아무런 액션을 취하지 않을 수도 있다. 

				N일 뒤에 최고의 수익을 남기기 위해서는 어떠한 전략을 수행해야 하는가? 

				입력 
				첫 줄에는 테스트 케이스의 수 T를 입력받는다. 
				다음에는 숫자 N을 입력한다. 
				그 다음 줄에는 N일 동안 예측한 주식의 가격을 입력한다. (모두 정수, 스페이스로 구분) 
				이것을 T만큼 반복한다.

				출력 
				각각의 테스트 케이스에 대해서 최고로 얻을 수 있는 수익을 출력한다. 

				제한
				 1 <= T <= 10 
				1 <= N <= 50000

				입력 예제 #1
				3
				3
				5 3 2
				3
				1 2 100
				4
				1 3 1 2

				출력 예제 #1
				0
				197
				3

				예제 설명 #1
				첫번째 테스트 케이스
				주가가 5 > 3 > 2로 떨어지기만 한다. 이래서는 수익을 낼수가 없다. 
				두번째 테스트 케이스
				1일과 2일에는 1주씩 구매한다. 3일때 모든 주식을 판매한다. 
				세번째 테스트 케이스 
				1일째 1주를 구매하고 2일째 이 것을 판매한다. 3일째 다시 1주를 구매하고 4일째 판매한다. 

				-----------------------------------------------------------------------------------

				더 큰 문자열 찾기


				알파벳 소문자로만 이루어진 문자열 w가 있다. w의 문자들을 재 조합해서 또다른 문자열 s를 만드는데 s는 w보다 그 크기가 크다. 
				(크기가 크다는 것은 사전 편찬 식으로 정렬했을 때 s가 w보다 뒤에 위치하게 된다는 의미이다.)

				입력 
				첫출에 테스트할 횟수 t를 입력받는다. 
				그 다음 줄 부터 문자열 w를 입력받는다. 

				출력
				각각의 테스트 케이스에 대해서 s를 출력한다. s가 여러개일 경우 그 중 가장 작은 것을 출력한다. 
				답이 존재하지 않으면 "no answer"를 출력한다. 

				제한 
				1 <= t <= 10^5 
				1 <= (w의 길이) <= 100 
				w는 알파벳 소문자로만 이루어져있으며, 길이가 100을 초과하지 않는다. 

				입력 예제 #1
				3
				ab
				bb
				hefg

				출력 예제 #1
				ba
				no answer
				hegf

				입력 예제 #2
				15
				zedawdvyyfumwpupuinbdbfndyehircmylbaowuptgmw
				zyyxwwtrrnmlggfeb
				ocsmerkgidvddsazqxjbqlrrxcotrnfvtnlutlfcafdlwiismslaytqdbvlmcpapfbmzxmftrkkqvkpflxpezzapllerxyzlcf
				biehzcmjckznhwrfgglverxsezxuqpj
				rebjvsszebhehuojrkkhszxltyqfdvayusylgmgkdivzlpmmtvbsavxvydldmsym
				unpzhmbgrrs
				jprfovzkdlmdcesdcpdchcwoedjchcovklhrhlzfeeptoewcqpxg
				ywsfmynmiylcjgrfrrmtyeeykffzkuphpajndwxjteyjba
				dkuashjzsdq
				gwakhcpkolybihkmxyecrdhsvycjrljajlmlqgpcnmvvkjlkvdowzdfikh
				nebsajjbbuifimjpdcqfygeitief
				qetpicxagjkydehfnvfxrtigljlheulcsfidjjozbsnomygqbcmpffwswptbgkzrbgqwnczrcfynjmhebfbgseuhckbtuynvbo
				xuqfobndhsnsztifmqpnencxkllnpmbfqihtgdgxjhsvitlgtodhcydfb
				xqdwkjpkmrvkfnztozzlqtuxzxyxwowf
				yewluyxiwiprnajrtkeilolkmqidazhiar

				출력 예제 #2
				zedawdvyyfumwpupuinbdbfndyehircmylbaowuptgwm no answer ocsmerkgidvddsazqxjbqlrrxcotrnfvtnlutlfcafdlwiismslaytqdbvlmcpapfbmzxmftrkkqvkpflxpezzapllerxyzlfc biehzcmjckznhwrfgglverxsjepquxz rebjvsszebhehuojrkkhszxltyqfdvayusylgmgkdivzlpmmtvbsavxvydldmyms unpzhmbgrsr jprfovzkdlmdcesdcpdchcwoedjchcovklhrhlzfeeptoewcqxgp ywsfmynmiylcjgrfrrmtyeeykffzkuphpajndwxjtjabey dkuashjzsqd gwakhcpkolybihkmxyecrdhsvycjrljajlmlqgpcnmvvkjlkvdowzdfkhi nebsajjbbuifimjpdcqfygeitife qetpicxagjkydehfnvfxrtigljlheulcsfidjjozbsnomygqbcmpffwswptbgkzrbgqwnczrcfynjmhebfbgseuhckbtuynvob xuqfobndhsnsztifmqpnencxkllnpmbfqihtgdgxjhsvitlgtodhcyfbd xqdwkjpkmrvkfnztozzlqtuxzxyxwwfo yewluyxiwiprnajrtkeilolkmqidazhira


				-----------------------------------------------------------------------------------

				원형 도시와 파출소


				2차원 좌표계에서 원으로 생긴 도시가 있다. 그 도시의 중심점 좌표는 (0,0)이며 정사각형 격자형 Cell위에 놓여져 있다. 각 Cell의 크기는 1X1이다. (모눈종위 위에 그려진 원이 도시, 모눈 종위 위의 격자 하나 하나가 Cell이라고 생각하면 된다) 
				이 도시에는 경찰서가 하나 있는데 도시의 원에 완전히 포함되어 있는 Cell에만 영향이 미친다. 즉 원형 도시의 테두리가 걸쳐있는 Cell에는 영향을 미칠 수 가 없다. 
				그래서 k개의 파출소를 건설해서 영향이 미치지 않은 곳도 보호하려고 한다. 파출소는 자신이 위치한 하나의 Cell만 보호할 수 있다. 
				도시의 반지름 r과 추가할 파출소의 수 k가 주어졌을 때 도시의 모든 Cell을 보호 할 수 있는지 여부를 판단하는 프로그램을 작성한다. 

				입력 
				첫번째 줄에 테스트 케이스의 수 t를 입력받는다. 
				다음 줄 한줄에 r과 k를 스페이스로 구분해서 입력받는다. 

				제한 
				1 <= t <= 10^3 
				1 <= r <= 2 * 10 ^ 9 
				0 <= r <= 2 * 10 ^ 9 

				출력 
				각각의 테스트 케이스에 대해서 도시에 속한 모든 Cell을 보호 가능하면 "possible"을 출력, 그렇지 않으면 "impossible"을 출력 

				입력 예제 #1
				5
				1 3
				1 4
				4 4
				25 11
				25 12

				출력 예제 #1
				impossible
				possible
				possible
				impossible
				possible 

				-----------------------------------------------------------------------------------

				다음의 조건을 만족하는 순열을 여우 순열이라고 한다.
				조건 1) 순열은 작아지지 않는다. 즉 바로 앞의 숫자보다 크거나 최소한 같아야 한다.
				조건 2) 가장 많이 반복된 숫자는 오직 하나이다.

				예1) 1, 1, 2, 3, 4
				이 순열을 여우 순열이다. 뒤로 갈수록 커지고 가장 많이 반복된 숫자는 1하나이다.

				예2) 1, 1, 2, 2
				이 순열은 여우 순열이 아니다. 뒤로 갈수록 커지지만 가장 많이 반복된 숫자가 1, 2로 두개이기 때문이다.

				예3) 2, 1, 1
				이 순열은 여우 순열이 아니다. 뒤의 숫자가 앞의 숫자보다 더 작다.

				lo부터 hi까지의 범위의 숫자 n개로 만들 수 있는 모든 여우 순열의 수를 구하는 프로그램을 작성하라.
				(lo <= 숫자 <= hi)

				입력
				첫번째 줄에 테스트 케이스의 수 T를 입력받는다.
				다음 줄 부터 n, lo, hi를 스페이스로 구분해서 입력받는다.

				출력
				각 테스트 케이스에 대해서 가능한 여우 순열의 수를 한줄에 하나씩 출력한다.

				제한
				1 ≤ T ≤ 5
				1 ≤ lo, hi ≤ 109
				lo ≤ hi
				0 ≤ |hi - lo| < 10^5
				1 ≤ n ≤ 10^5

				입력 예제 #1
				5
				2 1 1
				2 1 3
				3 1 2
				4 4 5
				10 2 4

				출력 예제 #1
				1
				3
				4
				4
				60

				예제 설명 #1
				첫번째 테스트 케이스의 경우 (1, 1)이 유일한 여우 순열이다.
				2번째 테스틔 케이스의 경우 (1, 1) (2, 2) (3, 3) 세개의 여우 순열이 가능하다.
				3번째는 (1, 1, 1) (2, 2, 2) (1, 1, 2), (1, 2, 2) 네개의 여우 순열이 가능하다. 

				-----------------------------------------------------------------------------------

				정수 트리플 (Triples) - 고급


				정수 배열 d가 있다. 
				다음을 만족하는 트리플의 수를 구하라 
				d[i] < d[j] < d[k], i < j < k 
				(이러한 트리플을  distinct ascending triples이라고 한다.)

				입력
				첫째 줄에 배열의 크기 N을 입력바는다. 
				두번째 줄에는 N개의 정수를 입력받는다. (스페이스로 구분) 

				출력 
				문제의 조건을 만족하는 트리플의 수를 출력한다. 

				제한 
				N <= 10^5
				배열에 속한 모든 정수값은 0보다 크고 2^16 - 1 보다 작다. 

				예제 입력 #1
				6 
				1 1 2 2 3 4

				예제 출력 #1
				4 

				예제 설명 #1 
				조건을 만족하는 트리플은 다음과 갔다. 
				(1,2,3) 
				(1,2,4) 
				(1,3,4) 
				(2,3,4)

				Advanced 
				이 문제는 위에서 풀었던 문제와 동일하다. 
				단 아래의 조건이 추가된다. 

				배열에 속한 모든 정수값은 최대 두번씩만 나올 수 있다. 
				Time Complexity가 O (N Log N)을 만족하도록 한다. 

				Hint 
				1) 트리플을 구하기 전에 tuples를 먼저 구한다.
				2) Fenwick tree를 이용한다. 

				-----------------------------------------------------------------------------------
*/

	}
}
